from django.shortcuts import render, redirect, get_object_or_404
from django.db.models import Q
from .models import Exploit, ExploitFile, DirectoryFile
from .forms import ExploitForm, LoginForm
from django.contrib import messages, auth
from django.contrib.auth import authenticate, login, logout
from django.forms import formset_factory
from django.http import HttpResponse, JsonResponse, Http404, FileResponse
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth.decorators import permission_required, user_passes_test
from uuid import UUID
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
import logging
import json
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.db import transaction
import os
import re
from django.core.files.storage import FileSystemStorage
from django.utils.crypto import get_random_string
from exploitdb.exploitdb import settings
from django.urls import reverse, reverse_lazy
from django.http import FileResponse
import mimetypes
import os
from django.views.generic import UpdateView, DeleteView, DetailView
from operator import attrgetter
from itertools import groupby

logger = logging.getLogger(__name__)

def admin_required(user):
    return user.is_authenticated and user.is_superuser

@user_passes_test(admin_required, login_url='admin_login')
# def add_exploit_view(request):
#     if request.method == 'POST':
#         form = ExploitForm(request.POST, request.FILES)
        
#         if form.is_valid():
#             exploit = form.save()

#             # Handle individual file uploads
#             for uploaded_file in request.FILES.getlist('files'):
#                 ExploitFile.objects.create(
#                     exploit=exploit,
#                     file=uploaded_file,
#                     is_folder_file=False
#                 )

#             # Handle multiple folders and extract files correctly
#             for uploaded_file in request.FILES.getlist('folders'):
#                 folder_path = uploaded_file.name  # Gets folder structure
#                 ExploitFile.objects.create(
#                     exploit=exploit,
#                     file=uploaded_file,
#                     is_folder_file=True
#                 )

#             return redirect('exploit_detail', exploit_identifier=exploit.id)

#     else:
#         form = ExploitForm()

#     return render(request, 'add_exploit.html', {'form': formdef add_exploit(request):
def add_exploit_view(request):
    if request.method == 'POST':
        form = ExploitForm(request.POST)
        
        if form.is_valid():
            exploit = form.save()

            description = request.POST.get('description')
            
            # Find all image URLs in the description
            img_urls = re.findall(r'<img[^>]+src="([^">]+)"', description)

            # Store media URLs separately (optional for reference)
            for url in img_urls:
                ExploitFile.objects.create(
                    exploit=exploit,
                    file=url,  # Store the media URL
                    name='Embedded Image'
                )

            # Save the updated description with media URLs
            exploit.description = description
            exploit.save()

            # Process individual files
            if 'files' in request.FILES:
                files = request.FILES.getlist('files')
                for file in files:
                    ExploitFile.objects.create(
                        exploit=exploit,
                        file=file,
                        name=file.name
                    )

            # Process folders (directory structure)
            if 'folders' in request.FILES:
                folders = request.FILES.getlist('folders')
                for file in folders:
                    # Get relative path from webkit
                    relative_path = file.name
                    if hasattr(file, 'webkitRelativePath') and file.webkitRelativePath:
                        relative_path = file.webkitRelativePath

                    # Get directory name (first segment of the path)
                    path_parts = relative_path.split('/')
                    directory_name = path_parts[0] if len(path_parts) > 1 else ""
                    
                    DirectoryFile.objects.create(
                        exploit=exploit,
                        file=file,
                        directory_name=directory_name,
                        relative_path=relative_path
                    )
            
            messages.success(request, 'Exploit added successfully!')
            return redirect('exploit_detail', exploit_identifier=exploit.id)
    else:
        form = ExploitForm()
    
    return render(request, 'add_exploit.html', {'form': form})

@csrf_exempt
def upload_media(request):
    if request.method == 'POST' and request.FILES.get('image'):
        image = request.FILES['image']

        # Store image in media folder
        fs = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads'))
        filename = fs.save(get_random_string(10) + '-' + image.name, image)
        
        # Generate the media URL
        media_url = fs.url('uploads/' + filename)

        return JsonResponse({'url': media_url})

    return JsonResponse({'error': 'Invalid request'}, status=400)

# --- Update Exploit View ---import os
import uuid
from django.conf import settings
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.http import JsonResponse
from django.contrib.auth.decorators import user_passes_test
from operator import attrgetter
from itertools import groupby

@user_passes_test(admin_required, login_url='admin_login')
def update_exploit(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)
    
    # Check if it's an AJAX request
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'

    # Load existing content into Draft.js JSON format
    existing_content = exploit.description if exploit.description else ""

    # Handle file deletion (AJAX)
    if request.method == 'POST' and is_ajax and 'delete_file' in request.POST:
        file_id = request.POST.get('file_id')
        file_type = request.POST.get('file_type')
        
        try:
            if file_type == 'exploit_file':
                file_obj = ExploitFile.objects.get(id=file_id, exploit=exploit)
            else:  # directory_file
                file_obj = DirectoryFile.objects.get(id=file_id, exploit=exploit)
                
            # Delete the actual file from storage
            if file_obj.file:
                if os.path.isfile(file_obj.file.path):
                    os.remove(file_obj.file.path)
                    
            # Delete the database record
            file_obj.delete()
            return JsonResponse({'success': True})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})

    if request.method == 'POST':
        form = ExploitForm(request.POST, request.FILES, instance=exploit)
        
        # Handle AJAX file uploads separately
        if is_ajax and not 'delete_file' in request.POST:
            success = True
            error_message = ""
            
            try:
                # Handle new files
                if request.FILES.getlist('files'):
                    files = request.FILES.getlist('files')
                    for file in files:
                        # Generate unique name to prevent overwriting
                        unique_id = uuid.uuid4().hex
                        
                        ExploitFile.objects.create(
                            exploit=exploit,
                            file=file,
                            name=file.name
                        )

                # Handle new folders
                if request.FILES.getlist('folders[]'):
                    folders = request.FILES.getlist('folders[]')
                    for file in folders:
                        # Get the relative path
                        relative_path = file.name
                        
                        # Check if the file has webkitRelativePath as an attribute
                        if hasattr(file, 'relative_path'):
                            relative_path = file.relative_path
                        
                        # Split path to get directory name
                        path_parts = relative_path.split('/')
                        directory_name = path_parts[0] if len(path_parts) > 1 else ""

                        # Check if a file with same path exists
                        existing_file = DirectoryFile.objects.filter(
                            exploit=exploit,
                            relative_path=relative_path
                        ).first()
                        
                        if existing_file:
                            # Update the existing file
                            existing_file.file = file
                            existing_file.save()
                        else:
                            # Create new file record
                            DirectoryFile.objects.create(
                                exploit=exploit,
                                file=file,
                                name=relative_path,
                                directory_name=directory_name,
                                relative_path=relative_path
                            )
                
            except Exception as e:
                success = False
                error_message = str(e)
            
            # Return JSON response for AJAX requests
            return JsonResponse({
                'success': success, 
                'error': error_message
            })
            
        # Handle form submission normally
        elif form.is_valid():
            exploit = form.save(commit=False)
            
            # Update description
            if 'description' in request.POST:
                exploit.description = request.POST['description']
            
            exploit.save()
            
            # Process files and folders for non-JavaScript fallback
            if request.FILES.getlist('files'):
                files = request.FILES.getlist('files')
                for file in files:
                    ExploitFile.objects.create(
                        exploit=exploit,
                        file=file,
                        name=file.name
                    )
                    
            if request.FILES.getlist('folders[]'):
                folders = request.FILES.getlist('folders[]')
                for file in folders:
                    relative_path = file.name
                    if hasattr(file, 'relative_path'):
                        relative_path = file.relative_path
                    
                    path_parts = relative_path.split('/')
                    directory_name = path_parts[0] if len(path_parts) > 1 else ""
                    
                    # Check for existing file
                    existing_file = DirectoryFile.objects.filter(
                        exploit=exploit,
                        relative_path=relative_path
                    ).first()
                    
                    if existing_file:
                        existing_file.file = file
                        existing_file.save()
                    else:
                        DirectoryFile.objects.create(
                            exploit=exploit,
                            file=file,
                            name=relative_path,
                            directory_name=directory_name,
                            relative_path=relative_path
                        )
            
            messages.success(request, 'Exploit updated successfully!')
            return redirect('exploit_detail', exploit_identifier=exploit.id)
        else:
            # Add form errors as messages
            for field, errors in form.errors.items():
                for error in errors:
                    messages.error(request, f"{field}: {error}")

    else:
        form = ExploitForm(instance=exploit)

    # Get existing files
    uploaded_files = ExploitFile.objects.filter(exploit=exploit)
    directory_files = DirectoryFile.objects.filter(exploit=exploit)

    # Group directory files by folder
    grouped_files = []
    directory_files = sorted(directory_files, key=attrgetter('directory_name'))
    
    for directory_name, files in groupby(directory_files, key=attrgetter('directory_name')):
        grouped_files.append({
            'grouper': directory_name,
            'list': list(files)
        })

    context = {
        'form': form,
        'exploit': exploit,
        'uploaded_files': uploaded_files,
        'directory_list': grouped_files,
        'existing_content': existing_content,
        'MEDIA_URL': settings.MEDIA_URL
    }

    return render(request, 'update_exploit.html', context)

@user_passes_test(admin_required, login_url='admin_login')
@method_decorator(csrf_exempt, name='dispatch')
def delete_file(request, file_id):
    """
    Delete individual file by ID
    """
    if request.method == 'DELETE':
        file = get_object_or_404(ExploitFile, id=file.id)
        file.delete()
        return JsonResponse({'success': True, 'message': 'File deleted successfully'})
    return JsonResponse({'success': False, 'error': 'Invalid request method'})

@user_passes_test(admin_required, login_url='admin_login')
@method_decorator(csrf_exempt, name='dispatch')
def delete_directory_file(request, file_id):
    """
    Delete individual folder by ID
    """
    if request.method == 'DELETE':
        folder = get_object_or_404(DirectoryFile, id=folder.id)
        folder.delete()
        return JsonResponse({'success': True, 'message': 'Folder deleted successfully'})
    return JsonResponse({'success': False, 'error': 'Invalid request method'})

def home_view(request):
    query = request.GET.get('q', '')  # Get the search query from the URL
    category_filter = request.GET.get('category', '')  # Get the category filter from the URL
    sort_by = request.GET.get('sort', 'date_desc')  # Get the sort parameter from the URL

    exploits = Exploit.objects.all()  # Get all exploits by default

    if query:
        exploits = exploits.filter(
            Q(title__icontains=query) |
            Q(CVE_ID__icontains=query) |
            Q(CVSS__icontains=query) |
            Q(category__icontains=query)
        )

    if category_filter:
        exploits = exploits.filter(category__icontains=category_filter)

    categories = Exploit.objects.values_list('category', flat=True).distinct()

    return render(request, 'home.html', {
        'exploits': exploits,
        'query': query,
        'categories': categories,
        'selected_category': category_filter,
        'selected_sort': sort_by,  # Pass selected sort back to the template
    })

def exploit_detail_view(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)
    
    # Get all individual files
    uploaded_files = ExploitFile.objects.filter(exploit=exploit)
    
    # Get directory files and group them by directory
    directory_files = DirectoryFile.objects.filter(exploit=exploit)
    
    # Group by directory_name
    grouped_files = []
    directory_files = sorted(directory_files, key=attrgetter('directory_name'))
    
    for directory_name, files in groupby(directory_files, key=attrgetter('directory_name')):
        grouped_files.append({
            'grouper': directory_name,
            'list': list(files)
        })
    
    context = {
        'exploit': exploit,
        'uploaded_files': uploaded_files,
        'directory_list': grouped_files
    }
    
    return render(request, 'exploit_detail.html', context)

def build_folder_tree(folder_files):
    """
    Build a hierarchical tree structure from a list of files with paths.
    Returns a nested dictionary representing the folder structure.
    """
    root = {"name": "root", "children": {}, "files": []}
    
    for file in folder_files:
        path = file["path"]
        parts = path.split('/')
        filename = parts[-1]  # Last part is the filename
        
        # Navigate the tree structure
        current = root
        # Process all path parts except the filename
        for i, part in enumerate(parts[:-1]):
            if part == "":
                continue
                
            # Create the folder if it doesn't exist
            if part not in current["children"]:
                current["children"][part] = {
                    "name": part,
                    "children": {},
                    "files": []
                }
            
            # Move to the next level
            current = current["children"][part]
        
        # Add the file to the current folder
        current["files"].append({
            "name": filename,
            "url": file["url"]
        })
    
    return root
                    
def search_exploit(request):
    query = request.GET.get('q', '') # Get search query
    exploits = None

    if query:
            exploits = Exploit.objects.filter(
                Q(title__icontains=query) | 
                Q(CVE_ID__icontains=query) |
                Q(category__icontains=query)
            )

            if not exploits:
                messages.error(request, "No exploit found.")

    return render(request, 'search_delete_exploit.html', {'exploits': exploits, 'query': query})

@user_passes_test(admin_required, login_url='admin_login')
def delete_exploit(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)
    
    if request.method == 'POST':
        # Proceed with deletion of the exploit
        exploit.delete()
        messages.success(request, "Exploit successfully deleted.")
        return redirect('search_exploit')  # Redirect to the search page after deletion

    return render(request, 'confirm_delete.html', {'exploit': exploit})

@user_passes_test(admin_required, login_url='admin_login')
def confirm_delete_exploit(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)

    return render(request, 'confirm_delete.html', {'exploit': exploit})

@user_passes_test(admin_required, login_url='admin_login')
def delete_multiple_exploits(request):
    if request.method == 'POST':
        # Check if this is the confirmation submission
        if 'confirm_delete' in request.POST:
            # Get the list of exploit IDs from hidden fields
            exploit_ids = request.POST.getlist('exploit_ids')
            if exploit_ids:
                # Actually delete the exploits
                Exploit.objects.filter(id__in=exploit_ids).delete()
                messages.success(request, f"Successfully deleted {len(exploit_ids)} exploit(s).")
            else:
                messages.error(request, "No exploits were selected for deletion.")
            return redirect('search_exploit')
        else:
            # First submission - get selected exploits and show confirmation
            exploit_ids = request.POST.getlist('selected_exploits')
            if not exploit_ids:
                messages.error(request, "No exploits were selected for deletion.")
                return redirect('search_exploit')
            
            exploits = Exploit.objects.filter(id__in=exploit_ids)
            return render(request, 'confirm_multiple_delete.html', {'exploits': exploits})
    
    # If not a POST request, redirect to search page
    return redirect('search_exploit')

""" @user_passes_test(admin_required, login_url='admin_login')
def update_exploit(request, exploit_identifier):
    exploit_id = str(exploit_identifier)
    exploit = get_object_or_404(Exploit, id=exploit_identifier)

    if request.method == "POST":
        form = ExploitForm(request.POST, request.FILES, instance=exploit)
        if form.is_valid():
            form.save()
            for index, description in enumerate(request.POST.getlist("section_content[]")):
                desc_instance, created = ExploitDescription.objects.get_or_create(exploit=exploit, id=index+1)
                desc_instance.content = description
                desc_instance.image = request.FILES.getlist("section_image[]")[index] if "section_image[]" in request.FILES else desc_instance.image
                desc_instance.video = request.FILES.getlist("section_video[]")[index] if "section_video[]" in request.FILES else desc_instance.video
                desc_instance.file = request.FILES.getlist("section_file[]")[index] if "section_file[]" in request.FILES else desc_instance.file
                desc_instance.save()
            return redirect('home')

    else:
        form = ExploitForm(instance=exploit)
    
    return render(request, 'update_exploit.html', {'form': form, 'exploit': exploit}) """

logger = logging.getLogger(__name__)
    
def custom_login(request):
    form = LoginForm()
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect('home')  
        else:
            return HttpResponse("Invalid credentials", status=401)
    else:
        form = AuthenticationForm()
    return render(request, 'admin_login.html', {'form': form})
    
def custom_logout(request):
    logout(request)
    return render(request, 'admin_logout.html')

def protected_view(request):
    if not request.user.is_authenticated:
        return redirect("session_expired")
    return render(request, "home.html")

def session_expired(request):
    return render(request, "session_expired.html")

def check_session(request):
    return JsonResponse({"is_authenticated": request.user.is_authenticated})

@csrf_exempt
def upload_folder(request):
    if not request.user.is_authenticated or not request.user.is_superuser:
        return JsonResponse({"error": "Unauthorized"}, status=403)
        
    if request.method == "POST":
        try:
            files = request.FILES.getlist("files")
            exploit_id = request.POST.get("exploit_id")
            
            if not exploit_id:
                return JsonResponse({"error": "No exploit ID provided"}, status=400)
                
            exploit = get_object_or_404(Exploit, id=exploit_id)

            for file in files:
                ExploitFile.objects.create(exploit=exploit, file=file)

            return JsonResponse({"message": "Folder uploaded successfully!"})
        except Exception as e:
            logger.error(f"Error uploading folder: {str(e)}")
            return JsonResponse({"error": str(e)}, status=500)
    
    return JsonResponse({"error": "Invalid request method"}, status=405)

def view_file(request, file_path):
    try:
        # Security check: make sure the path doesn't contain ".." to prevent directory traversal
        if '..' in file_path:
            return HttpResponse("Invalid file path", status=400)
        
        # Construct the full path to the file
        full_path = os.path.join(settings.MEDIA_ROOT, file_path)
        
        if not os.path.exists(full_path):
            return HttpResponse(f"File not found: {full_path}", status=404)
        
        # Determine the content type
        content_type, _ = mimetypes.guess_type(full_path)
        if not content_type:
            content_type = 'application/octet-stream'
        
        # For text files, HTML, and other viewable formats
        viewable_types = ['text', 'xml', 'json', 'html', 'pdf', 'image', 'video', 'audio', 'csv', 'python', 'sh', 'zip', 'tar', 'gzip', 'javascript', 'css', 'tsv', 'tfevents', 'c', 'cpp']
        is_viewable = False
        for vtype in viewable_types:
            if content_type.startswith(vtype):
                is_viewable = True
                break
        
        if is_viewable:
            # Read file content and return as HttpResponse
            with open(full_path, 'r') as f:
                content = f.read()
                response = HttpResponse(content, content_type=content_type)
                response['Content-Disposition'] = f'inline; filename="{os.path.basename(file_path)}"'
                return response
        else:
            # For other files, still allow download
            response = FileResponse(open(full_path, 'rb'), content_type=content_type)
            response['Content-Disposition'] = f'inline; filename="{os.path.basename(file_path)}"'
            return response
            
    except Exception as e:
        print(f"Error in view_file: {str(e)}")
        return HttpResponse(f"Error viewing file: {str(e)}", status=500)