from django.shortcuts import render, redirect, get_object_or_404
from django.db.models import Q
from .models import Exploit, ExploitFile
from .forms import ExploitForm, LoginForm
from django.contrib import messages, auth
from django.contrib.auth import authenticate, login, logout
from django.forms import formset_factory
from django.http import HttpResponse, JsonResponse, Http404, FileResponse, HttpResponseNotAllowed
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth.decorators import permission_required, user_passes_test
from uuid import UUID
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.utils.decorators import method_decorator
import logging
import json
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.db import transaction
import os
import re
from urllib.parse import urlparse
from django.core.files.storage import FileSystemStorage
from django.utils.crypto import get_random_string
from exploitdb.exploitdb import settings
from django.urls import reverse, reverse_lazy
from django.http import FileResponse
import mimetypes
import os
from operator import attrgetter
from itertools import groupby
from collections import OrderedDict
logger = logging.getLogger(__name__)

def admin_required(user):
    return user.is_authenticated and user.is_superuser

@user_passes_test(admin_required, login_url='admin_login')
# def add_exploit_view(request):
#     if request.method == 'POST':
#         form = ExploitForm(request.POST, request.FILES)
        
#         if form.is_valid():
#             exploit = form.save()

#             # Handle individual file uploads
#             for uploaded_file in request.FILES.getlist('files'):
#                 ExploitFile.objects.create(
#                     exploit=exploit,
#                     file=uploaded_file,
#                     is_folder_file=False
#                 )

#             # Handle multiple folders and extract files correctly
#             for uploaded_file in request.FILES.getlist('folders'):
#                 folder_path = uploaded_file.name  # Gets folder structure
#                 ExploitFile.objects.create(
#                     exploit=exploit,
#                     file=uploaded_file,
#                     is_folder_file=True
#                 )

#             return redirect('exploit_detail', exploit_identifier=exploit.id)

#     else:
#         form = ExploitForm()

#     return render(request, 'add_exploit.html', {'form': formdef add_exploit(request):
def add_exploit_view(request):
    if request.method == 'POST':
        form = ExploitForm(request.POST)
        
        if form.is_valid():
            exploit = form.save()

            description = request.POST.get('description')
            
            # Find all image URLs in the description
            img_urls = re.findall(r'<img[^>]+src="([^">]+)"', description)

            # Save the updated description with media URLs
            exploit.description = description
            exploit.save()

            # Process individual files
            if 'files' in request.FILES:
                files = request.FILES.getlist('files')
                for file in files:
                    ExploitFile.objects.create(
                        exploit=exploit,
                        file=file,
                        name=file.name
                    )

            messages.success(request, 'Exploit added successfully!')
            return redirect('exploit_detail', exploit_identifier=exploit.id)
    else:
        form = ExploitForm()
    
    return render(request, 'add_exploit.html', {'form': form})

@csrf_exempt
def upload_media(request):
    if request.method == 'POST' and request.FILES.get('image'):
        image = request.FILES['image']

        # Store image in media folder
        fs = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads'))
        filename = fs.save(get_random_string(10) + '-' + image.name, image)
        
        # Generate the media URL
        media_url = fs.url('uploads/' + filename)

        return JsonResponse({'url': media_url})

    return JsonResponse({'error': 'Invalid request'}, status=400)

@user_passes_test(admin_required, login_url='admin_login')
def update_exploit(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)

    # Check if the user has permission to edit this exploit
    if not request.user.is_staff and exploit.author != request.user:
        return redirect('exploit_detail', exploit_id=exploit_identifier)

    if request.method == 'POST':
        form = ExploitForm(request.POST, instance=exploit)
        
        is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'

        if is_ajax:
            try:
                # Handle new file uploads
                if 'files' in request.FILES:
                    files = request.FILES.getlist('files')
                    for file in files:
                        ExploitFile.objects.create(
                            exploit=exploit,
                            name=file.name,
                            file=file,
                        )

                # Handle folder uploads
                if 'folders' in request.FILES:
                    folders = request.FILES.getlist('folders')
                    folder_paths = request.POST.getlist('folderPaths', [])

                    for i, file in enumerate(folders):
                        path = ''
                        if i < len(folder_paths):
                            full_path = folder_paths[i]
                            path = os.path.dirname(full_path)

                        ExploitFile.objects.create(
                            exploit=exploit,
                            name=os.path.basename(file.name),
                            file=file,
                        )

                return JsonResponse({'success': True})
            
            except Exception as e:
                return JsonResponse({'success': False, 'error': str(e)})

        # Handle regular form submission
        if form.is_valid():
            form.save()

            # Handle new file uploads (non-AJAX)
            if 'files' in request.FILES:
                files = request.FILES.getlist('files')
                for file in files:
                    ExploitFile.objects.create(
                        exploit=exploit,
                        name=file.name,
                        file=file,
                    )
            
            return redirect('exploit_detail', exploit_identifier=exploit.id)

    else:
        form = ExploitForm(instance=exploit)

    # ✅ Retrieve Existing Files and Folders
    uploaded_files = ExploitFile.objects.filter(exploit=exploit)

    return render(request, 'update_exploit.html', {
        'exploit': exploit,
        'form': form,
        'uploaded_files': uploaded_files,
    })


# ✅ Delete File/Folder Function
@csrf_exempt
@user_passes_test(admin_required, login_url='admin_login')
def delete_file(request, file_id):
    """
    Delete a file or folder from the update_exploit page.
    """
    if request.method == 'POST' and request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        try:
            file = get_object_or_404(ExploitFile, id=file_id)
            
            # Delete the file from the storage
            if file.file:
                file_path = file.file.path
                if os.path.exists(file_path):
                    os.remove(file_path)

            # Remove the file entry from the database
            file.delete()
            
            return JsonResponse({'success': True})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    
    return HttpResponseNotAllowed(['POST'])

def exploit_detail_view(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)
    
    # Get all individual files
    uploaded_files = ExploitFile.objects.filter(exploit=exploit)
    
    context = {
        'exploit': exploit,
        'uploaded_files': uploaded_files
    }
    
    return render(request, 'exploit_detail.html', context)

def home_view(request):
    query = request.GET.get('q', '')  # Get the search query from the URL
    category_filter = request.GET.get('category', '')  # Get the category filter from the URL
    sort_by = request.GET.get('sort', 'date_desc')  # Get the sort parameter from the URL

    exploits = Exploit.objects.all()  # Get all exploits by default

    if query:
        exploits = exploits.filter(
            Q(title__icontains=query) |
            Q(CVE_ID__icontains=query) |
            Q(CVSS__icontains=query) |
            Q(category__icontains=query)
        )

    if category_filter:
        exploits = exploits.filter(category__icontains=category_filter)

    categories = Exploit.objects.values_list('category', flat=True).distinct()

    return render(request, 'home.html', {
        'exploits': exploits,
        'query': query,
        'categories': categories,
        'selected_category': category_filter,
        'selected_sort': sort_by,  # Pass selected sort back to the template
    })
                    
def search_exploit(request):
    query = request.GET.get('q', '') # Get search query
    exploits = None

    if query:
            exploits = Exploit.objects.filter(
                Q(title__icontains=query) | 
                Q(CVE_ID__icontains=query) |
                Q(category__icontains=query)
            )

            if not exploits:
                messages.error(request, "No exploit found.")

    return render(request, 'search_delete_exploit.html', {'exploits': exploits, 'query': query})

@user_passes_test(admin_required, login_url='admin_login')
def delete_exploit(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)
    
    if request.method == 'POST':
        # Get all related files before deleting the exploit
        related_files = ExploitFile.objects.filter(exploit=exploit)
        
        # Delete physical files from storage
        files_deleted = 0
        for file in related_files:
            if file.file and hasattr(file.file, 'path') and os.path.exists(file.file.path):
                try:
                    os.remove(file.file.path)
                    files_deleted += 1
                except (OSError, PermissionError) as e:
                    messages.warning(request, f"Could not delete file {file.name}: {str(e)}")
        
        # Delete embedded images in description
        images_deleted = delete_embedded_images(exploit.description)
        
        # Proceed with deletion of the exploit (which will cascade delete the file records)
        exploit.delete()
        
        success_message = f"Exploit successfully deleted with {files_deleted} attachment(s)"
        if images_deleted > 0:
            success_message += f" and {images_deleted} embedded image(s)"
        messages.success(request, success_message + ".")
        
        return redirect('search_exploit')  # Redirect to the search page after deletion

    return render(request, 'confirm_delete.html', {'exploit': exploit})

@user_passes_test(admin_required, login_url='admin_login')
def delete_multiple_exploits(request):
    if request.method == 'POST':
        # Check if this is the confirmation submission
        if 'confirm_delete' in request.POST:
            # Get the list of exploit IDs from hidden fields
            exploit_ids = request.POST.getlist('exploit_ids')
            files_deleted = 0
            images_deleted = 0
            
            if exploit_ids:
                # Get all exploits first to process descriptions
                exploits = Exploit.objects.filter(id__in=exploit_ids)
                
                # Delete embedded images in each exploit's description
                for exploit in exploits:
                    images_deleted += delete_embedded_images(exploit.description)
                
                # First, get all related files for these exploits
                all_files = ExploitFile.objects.filter(exploit__id__in=exploit_ids)
                
                # Delete physical files from storage
                for file in all_files:
                    if file.file and hasattr(file.file, 'path') and os.path.exists(file.file.path):
                        try:
                            os.remove(file.file.path)
                            files_deleted += 1
                        except (OSError, PermissionError) as e:
                            messages.warning(request, f"Could not delete file {file.name}: {str(e)}")
                
                # Actually delete the exploits (which will cascade delete the file records)
                deleted_count = exploits.delete()[0]
                
                success_message = f"Successfully deleted {deleted_count} exploit(s) with {files_deleted} attachment(s)"
                if images_deleted > 0:
                    success_message += f" and {images_deleted} embedded image(s)"
                messages.success(request, success_message + ".")
            else:
                messages.error(request, "No exploits were selected for deletion.")
            return redirect('search_exploit')
        else:
            # First submission - get selected exploits and show confirmation
            exploit_ids = request.POST.getlist('selected_exploits')
            if not exploit_ids:
                messages.error(request, "No exploits were selected for deletion.")
                return redirect('search_exploit')
            
            exploits = Exploit.objects.filter(id__in=exploit_ids)
            
            # Count files and estimate embedded images for each exploit
            files_count = ExploitFile.objects.filter(exploit__id__in=exploit_ids).count()
            
            # Count embedded images (estimation)
            images_count = 0
            for exploit in exploits:
                # This gives a rough estimate without actually deleting
                images_count += len(re.findall(r'<img[^>]+src=["\']([^"\']+)["\']', exploit.description or ''))
            
            return render(request, 'confirm_multiple_delete.html', {
                'exploits': exploits, 
                'files_count': files_count,
                'images_count': images_count
            })
    
    # If not a POST request, redirect to search page
    return redirect('search_exploit')

def delete_embedded_images(description):
    """
    Find and delete any embedded images in the description that are stored on the server.
    Returns the count of images deleted.
    """
    if not description:
        return 0
    
    count = 0
    
    # Use a more comprehensive regex pattern to capture all img tags, including those at the beginning
    # This regex handles both single and double quotes around src attributes
    image_tags = re.findall(r'<img\s+[^>]*?src=(["\'])(.*?)\1[^>]*?>', description, re.DOTALL | re.IGNORECASE)
    
    # Process all found image sources (extract the src value from the tuple)
    for _, img_src in image_tags:
        # Clean up the src value
        img_src = img_src.strip()
        
        # Determine if this is a local image (not an external URL)
        url_parts = urlparse(img_src)
        
        # Skip external images or data URLs
        if (url_parts.netloc and url_parts.netloc not in ['', 'localhost', '127.0.0.1']) or img_src.startswith('data:'):
            continue
        
        # Convert URL path to file system path
        file_path = None
        
        # Handle various URL formats
        if img_src.startswith('/media/'):
            # Standard Django media URL
            relative_path = img_src.replace('/media/', '', 1)
            file_path = os.path.join(settings.MEDIA_ROOT, relative_path)
        elif img_src.startswith('/static/'):
            # Static files
            relative_path = img_src.replace('/static/', '', 1)
            file_path = os.path.join(settings.STATIC_ROOT, relative_path)
        elif img_src.startswith('/'):
            # Root-relative URL
            # Try both media and static roots
            media_path = os.path.join(settings.MEDIA_ROOT, img_src.lstrip('/'))
            static_path = os.path.join(settings.STATIC_ROOT, img_src.lstrip('/'))
            
            if os.path.exists(media_path):
                file_path = media_path
            elif os.path.exists(static_path):
                file_path = static_path
        else:
            # Relative URL - try multiple possibilities
            media_path = os.path.join(settings.MEDIA_ROOT, img_src)
            static_path = os.path.join(settings.STATIC_ROOT, img_src)
            
            if os.path.exists(media_path):
                file_path = media_path
            elif os.path.exists(static_path):
                file_path = static_path
            else:
                # Try to handle images uploaded to specifically named directories
                for upload_dir in ['uploads', 'images', 'embedded', 'exploits', 'media/uploads', 'media/images', 'media/embedded', 'media/exploits']:
                    potential_path = os.path.join(settings.MEDIA_ROOT, upload_dir, os.path.basename(img_src))
                    if os.path.exists(potential_path):
                        file_path = potential_path
                        break
        
        # Try to delete the file if we found a valid path
        if file_path and os.path.exists(file_path) and os.path.isfile(file_path):
            try:
                os.remove(file_path)
                count += 1
                print(f"Successfully deleted: {file_path}")  # Debug log
            except (OSError, PermissionError) as e:
                # Log the error but continue with other files
                print(f"Error deleting embedded image {img_src} at {file_path}: {e}")
        else:
            # Try a simpler approach using just the filename as a last resort
            filename = os.path.basename(img_src)
            last_resort_paths = [
                os.path.join(settings.MEDIA_ROOT, filename),
                os.path.join(settings.MEDIA_ROOT, 'uploads', filename),
                os.path.join(settings.MEDIA_ROOT, 'images', filename),
                os.path.join(settings.MEDIA_ROOT, 'embedded', filename)
            ]
            
            for path in last_resort_paths:
                if os.path.exists(path) and os.path.isfile(path):
                    try:
                        os.remove(path)
                        count += 1
                        print(f"Successfully deleted using filename match: {path}")
                        break
                    except (OSError, PermissionError) as e:
                        print(f"Error deleting embedded image by filename {filename} at {path}: {e}")
            else:
                print(f"Could not locate file for deletion: {img_src}")  # Debug log
    
    return count

@user_passes_test(admin_required, login_url='admin_login')
def confirm_delete_exploit(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)

    return render(request, 'confirm_delete.html', {'exploit': exploit})

""" @user_passes_test(admin_required, login_url='admin_login')
def update_exploit(request, exploit_identifier):
    exploit_id = str(exploit_identifier)
    exploit = get_object_or_404(Exploit, id=exploit_identifier)

    if request.method == "POST":
        form = ExploitForm(request.POST, request.FILES, instance=exploit)
        if form.is_valid():
            form.save()
            for index, description in enumerate(request.POST.getlist("section_content[]")):
                desc_instance, created = ExploitDescription.objects.get_or_create(exploit=exploit, id=index+1)
                desc_instance.content = description
                desc_instance.image = request.FILES.getlist("section_image[]")[index] if "section_image[]" in request.FILES else desc_instance.image
                desc_instance.video = request.FILES.getlist("section_video[]")[index] if "section_video[]" in request.FILES else desc_instance.video
                desc_instance.file = request.FILES.getlist("section_file[]")[index] if "section_file[]" in request.FILES else desc_instance.file
                desc_instance.save()
            return redirect('home')

    else:
        form = ExploitForm(instance=exploit)
    
    return render(request, 'update_exploit.html', {'form': form, 'exploit': exploit}) """

logger = logging.getLogger(__name__)
    
def custom_login(request):
    form = LoginForm()
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect('home')  
        else:
            return HttpResponse("Invalid credentials", status=401)
    else:
        form = AuthenticationForm()
    return render(request, 'admin_login.html', {'form': form})
    
def custom_logout(request):
    logout(request)
    return render(request, 'admin_logout.html')

def protected_view(request):
    if not request.user.is_authenticated:
        return redirect("session_expired")
    return render(request, "home.html")

def session_expired(request):
    return render(request, "session_expired.html")

def check_session(request):
    return JsonResponse({"is_authenticated": request.user.is_authenticated})

def view_file(request, file_path):
    try:
        if '..' in file_path:
            return HttpResponse("Invalid file path", status=400)
        
        # Construct the full path to the file
        full_path = os.path.join(settings.MEDIA_ROOT, file_path)
        
        if not os.path.exists(full_path):
            return HttpResponse(f"File not found: {full_path}", status=404)
        
        # Determine the content type
        content_type, _ = mimetypes.guess_type(full_path)
        if not content_type:
            content_type = 'application/octet-stream'
        
        # For text files, HTML, and other viewable formats
        viewable_types = ['text', 'xml', 'json', 'html', 'pdf', 'image', 'video', 'audio', 'csv', 'python', 'sh', 'zip', 'tar', 'gzip', 'javascript', 'css', 'tsv', 'tfevents', 'c', 'cpp']
        is_viewable = False
        for vtype in viewable_types:
            if content_type.startswith(vtype):
                is_viewable = True
                break
        
        if is_viewable:
            # Read file content and return as HttpResponse
            with open(full_path, 'r') as f:
                content = f.read()
                response = HttpResponse(content, content_type=content_type)
                response['Content-Disposition'] = f'inline; filename="{os.path.basename(file_path)}"'
                return response
        else:
            # For other files, still allow download
            response = FileResponse(open(full_path, 'rb'), content_type=content_type)
            response['Content-Disposition'] = f'inline; filename="{os.path.basename(file_path)}"'
            return response
            
    except Exception as e:
        print(f"Error in view_file: {str(e)}")
        return HttpResponse(f"Error viewing file: {str(e)}", status=500)
