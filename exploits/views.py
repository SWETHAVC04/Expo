from django.shortcuts import render, redirect, get_object_or_404
from django.db.models import Q
from .models import Exploit, ExploitFile
from .forms import ExploitForm, LoginForm
from django.contrib import messages, auth
from django.contrib.auth import authenticate, login, logout
from django.forms import formset_factory
from django.http import HttpResponse, JsonResponse, Http404, FileResponse, HttpResponseNotAllowed
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth.decorators import permission_required, user_passes_test
from uuid import UUID
from django.views.decorators.http import require_POST, require_http_methods
from django.views.decorators.csrf import csrf_exempt, csrf_protect
from django.utils.decorators import method_decorator
import logging
import json
from django.core.files.storage import default_storage
from django.core.files.base import ContentFile
from django.db import transaction
import os
import re
from urllib.parse import urlparse
from django.core.files.storage import FileSystemStorage
from django.utils.crypto import get_random_string
from exploitdb.exploitdb import settings
from django.urls import reverse, reverse_lazy
import mimetypes
from operator import attrgetter
from itertools import groupby
from collections import OrderedDict
from datetime import datetime
import zipfile
import shutil

MAX_IMAGE_SIZE = 5 * 1024 * 1024

logger = logging.getLogger(__name__)

def admin_required(user):
    return user.is_authenticated and user.is_superuser

@user_passes_test(admin_required, login_url='admin_login')
# def add_exploit_view(request):
#     if request.method == 'POST':
#         form = ExploitForm(request.POST, request.FILES)
        
#         if form.is_valid():
#             exploit = form.save()

#             # Handle individual file uploads
#             for uploaded_file in request.FILES.getlist('files'):
#                 ExploitFile.objects.create(
#                     exploit=exploit,
#                     file=uploaded_file,
#                     is_folder_file=False
#                 )

#             # Handle multiple folders and extract files correctly
#             for uploaded_file in request.FILES.getlist('folders'):
#                 folder_path = uploaded_file.name  # Gets folder structure
#                 ExploitFile.objects.create(
#                     exploit=exploit,
#                     file=uploaded_file,
#                     is_folder_file=True
#                 )

#             return redirect('exploit_detail', exploit_identifier=exploit.id)

#     else:
#         form = ExploitForm()

#     return render(request, 'add_exploit.html', {'form': formdef add_exploit(request):
def add_exploit_view(request):
    if request.method == 'POST':
        form = ExploitForm(request.POST)
        
        if form.is_valid():
            exploit = form.save(commit=False)
            description = request.POST.get('description')
            
            # Find all image URLs in the description
            img_urls = re.findall(r'<img[^>]+src="([^">]+)"', description)

            # Save the updated description with media URLs
            exploit.description = form.cleaned_data['description']
            exploit.save()

            # Process individual files
            if 'files' in request.FILES:
                files = request.FILES.getlist('files')
                for file in files:
                    ExploitFile.objects.create(
                        exploit=exploit,
                        file=file,
                        name=file.name
                    )

            messages.success(request, 'Exploit added successfully!')
            return redirect('exploit_detail', exploit_identifier=exploit.id)
        else:
            return render(request, 'add_exploit.html', {'form': form})
    else:
        form = ExploitForm()
    return render(request, 'add_exploit.html', {'form': form})

@csrf_protect
@require_POST
def upload_media(request):
    if request.method == 'POST' and request.FILES.get('image'):
        image = request.FILES['image']
        content_type = image.content_type 
        if not image or not content_type.startswith('image/'):
            return JsonResponse({'error': 'Invalid image format'}, status=400)
          
        if image.size > MAX_IMAGE_SIZE:
            return JsonResponse({'error': 'Image size exceeds 5MB'}, status=400)
        

        # Store image in media folder
        fs = FileSystemStorage(location=os.path.join(settings.MEDIA_ROOT, 'uploads'))
        filename = fs.save(get_random_string(10) + '-' + image.name, image)
        
        # Generate the media URL
        media_url = fs.url('uploads/' + filename)

        return JsonResponse({'url': media_url})

    return JsonResponse({'error': 'Invalid request'}, status=400)

@user_passes_test(admin_required, login_url='admin_login')
def update_exploit(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)

    # Check if the user has permission to edit this exploit
    if not request.user.is_staff and exploit.author != request.user:
        return redirect('exploit_detail', exploit_id=exploit_identifier)

    if request.method == 'POST':
        form = ExploitForm(request.POST, instance=exploit)
        
        is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'

        if is_ajax:
            try:
                # Handle new file uploads
                if 'files' in request.FILES:
                    files = request.FILES.getlist('files')
                    for file in form.cleaned_data['files']:
                        ExploitFile.objects.create(
                            exploit=exploit,
                            name=file.name,
                            file=file,
                        )

                return JsonResponse({'success': True})
            
            except Exception as e:
                return JsonResponse({'success': False, 'error': str(e)})

        # Handle regular form submission
        if form.is_valid():
            form.save()

            # Handle new file uploads (non-AJAX)
            if 'files' in request.FILES:
                files = request.FILES.getlist('files')
                for file in files:
                    ExploitFile.objects.create(
                        exploit=exploit,
                        name=file.name,
                        file=file,
                    )
            
            return redirect('exploit_detail', exploit_identifier=exploit.id)

    else:
        form = ExploitForm(instance=exploit)

    # ✅ Retrieve Existing Files and Folders
    uploaded_files = ExploitFile.objects.filter(exploit=exploit)

    return render(request, 'update_exploit.html', {
        'exploit': exploit,
        'form': form,
        'uploaded_files': uploaded_files,
    })


# ✅ Delete File/Folder Function
@csrf_exempt
@user_passes_test(admin_required, login_url='admin_login')
def delete_file(request, file_id):
    """
    Delete a file or folder from the update_exploit page.
    """
    if request.method == 'POST' and request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        try:
            file = get_object_or_404(ExploitFile, id=file_id)
            
            # Delete the file from the storage
            if file.file:
                file_path = file.file.path
                if os.path.exists(file_path):
                    os.remove(file_path)

            # Remove the file entry from the database
            file.delete()
            
            return JsonResponse({'success': True})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    
    return HttpResponseNotAllowed(['POST'])

def exploit_detail_view(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)
    
    # Get all individual files
    uploaded_files = ExploitFile.objects.filter(exploit=exploit)
    
    context = {
        'exploit': exploit,
        'uploaded_files': uploaded_files
    }
    
    return render(request, 'exploit_detail.html', context)

def home_view(request):
    query = request.GET.get('q', '')  # Get the search query from the URL
    category_filter = request.GET.get('category', '')  # Get the category filter from the URL
    sort_by = request.GET.get('sort', 'date_desc')  # Get the sort parameter from the URL

    exploits = Exploit.objects.all()  # Get all exploits by default

    if query:
        exploits = exploits.filter(
            Q(title__icontains=query) |
            Q(CVE_ID__icontains=query) |
            Q(CVSS__icontains=query) |
            Q(category__icontains=query)
        )

    if category_filter:
        exploits = exploits.filter(category__icontains=category_filter)

    categories = Exploit.objects.values_list('category', flat=True).distinct()

    return render(request, 'home.html', {
        'exploits': exploits,
        'query': query,
        'categories': categories,
        'selected_category': category_filter,
        'selected_sort': sort_by,  # Pass selected sort back to the template
    })
                    
def search_exploit(request):
    query = request.GET.get('q', '') # Get search query
    exploits = None

    if query:
            exploits = Exploit.objects.filter(
                Q(title__icontains=query) | 
                Q(CVE_ID__icontains=query) |
                Q(category__icontains=query)
            )

            if not exploits:
                messages.error(request, "No exploit found.")

    return render(request, 'search_delete_exploit.html', {'exploits': exploits, 'query': query})

@user_passes_test(admin_required, login_url='admin_login')
def delete_exploit(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)
    
    if request.method == 'POST':
        # Get all related files before deleting the exploit
        related_files = ExploitFile.objects.filter(exploit=exploit)
        
        # Delete physical files from storage
        files_deleted = 0
        for file in related_files:
            if file.file and hasattr(file.file, 'path') and os.path.exists(file.file.path):
                try:
                    os.remove(file.file.path)
                    files_deleted += 1
                except (OSError, PermissionError) as e:
                    messages.warning(request, f"Could not delete file {file.name}: {str(e)}")
        
        # Delete embedded images in description
        images_deleted = delete_embedded_images(exploit.description)
        
        # Proceed with deletion of the exploit (which will cascade delete the file records)
        exploit.delete()
        
        success_message = f"Exploit successfully deleted with {files_deleted} attachment(s)"
        if images_deleted > 0:
            success_message += f" and {images_deleted} embedded image(s)"
        messages.success(request, success_message + ".")
        
        return redirect('search_exploit')  # Redirect to the search page after deletion

    return render(request, 'confirm_delete.html', {'exploit': exploit})

@user_passes_test(admin_required, login_url='admin_login')
def delete_multiple_exploits(request):
    if request.method == 'POST':
        # Check if this is the confirmation submission
        if 'confirm_delete' in request.POST:
            # Get the list of exploit IDs from hidden fields
            exploit_ids = request.POST.getlist('exploit_ids')
            files_deleted = 0
            images_deleted = 0
            
            if exploit_ids:
                # Get all exploits first to process descriptions
                exploits = Exploit.objects.filter(id__in=exploit_ids)
                
                # Delete embedded images in each exploit's description
                for exploit in exploits:
                    images_deleted += delete_embedded_images(exploit.description)
                
                # First, get all related files for these exploits
                all_files = ExploitFile.objects.filter(exploit__id__in=exploit_ids)
                
                # Delete physical files from storage
                for file in all_files:
                    if file.file and hasattr(file.file, 'path') and os.path.exists(file.file.path):
                        try:
                            os.remove(file.file.path)
                            files_deleted += 1
                        except (OSError, PermissionError) as e:
                            messages.warning(request, f"Could not delete file {file.name}: {str(e)}")
                
                # Actually delete the exploits (which will cascade delete the file records)
                deleted_count = exploits.delete()[0]
                
                success_message = f"Successfully deleted {deleted_count} exploit(s) with {files_deleted} attachment(s)"
                if images_deleted > 0:
                    success_message += f" and {images_deleted} embedded image(s)"
                messages.success(request, success_message + ".")
            else:
                messages.error(request, "No exploits were selected for deletion.")
            return redirect('search_exploit')
        else:
            # First submission - get selected exploits and show confirmation
            exploit_ids = request.POST.getlist('selected_exploits')
            if not exploit_ids:
                messages.error(request, "No exploits were selected for deletion.")
                return redirect('search_exploit')
            
            exploits = Exploit.objects.filter(id__in=exploit_ids)
            
            # Count files and estimate embedded images for each exploit
            files_count = ExploitFile.objects.filter(exploit__id__in=exploit_ids).count()
            
            # Count embedded images (estimation)
            images_count = 0
            for exploit in exploits:
                # This gives a rough estimate without actually deleting
                images_count += len(re.findall(r'<img[^>]+src=["\']([^"\']+)["\']', exploit.description or ''))
            
            return render(request, 'confirm_multiple_delete.html', {
                'exploits': exploits, 
                'files_count': files_count,
                'images_count': images_count
            })
    
    # If not a POST request, redirect to search page
    return redirect('search_exploit')

def delete_embedded_images(description):
    """
    Find and delete any embedded images in the description that are stored on the server.
    Returns the count of images deleted.
    """
    if not description:
        return 0
    
    count = 0
    
    # Use a more comprehensive regex pattern to capture all img tags, including those at the beginning
    # This regex handles both single and double quotes around src attributes
    image_tags = re.findall(r'<img\s+[^>]*?src=(["\'])(.*?)\1[^>]*?>', description, re.DOTALL | re.IGNORECASE)
    
    # Process all found image sources (extract the src value from the tuple)
    for _, img_src in image_tags:
        # Clean up the src value
        img_src = img_src.strip()
        
        # Determine if this is a local image (not an external URL)
        url_parts = urlparse(img_src)
        
        # Skip external images or data URLs
        if (url_parts.netloc and url_parts.netloc not in ['', 'localhost', '127.0.0.1']) or img_src.startswith('data:'):
            continue
        
        # Convert URL path to file system path
        file_path = None
        
        # Handle various URL formats
        if img_src.startswith('/media/'):
            # Standard Django media URL
            relative_path = img_src.replace('/media/', '', 1)
            file_path = os.path.join(settings.MEDIA_ROOT, relative_path)
        elif img_src.startswith('/static/'):
            # Static files
            relative_path = img_src.replace('/static/', '', 1)
            file_path = os.path.join(settings.STATIC_ROOT, relative_path)
        elif img_src.startswith('/'):
            # Root-relative URL
            # Try both media and static roots
            media_path = os.path.join(settings.MEDIA_ROOT, img_src.lstrip('/'))
            static_path = os.path.join(settings.STATIC_ROOT, img_src.lstrip('/'))
            
            if os.path.exists(media_path):
                file_path = media_path
            elif os.path.exists(static_path):
                file_path = static_path
        else:
            # Relative URL - try multiple possibilities
            media_path = os.path.join(settings.MEDIA_ROOT, img_src)
            static_path = os.path.join(settings.STATIC_ROOT, img_src)
            
            if os.path.exists(media_path):
                file_path = media_path
            elif os.path.exists(static_path):
                file_path = static_path
            else:
                # Try to handle images uploaded to specifically named directories
                for upload_dir in ['uploads', 'images', 'embedded', 'exploits', 'media/uploads', 'media/images', 'media/embedded', 'media/exploits']:
                    potential_path = os.path.join(settings.MEDIA_ROOT, upload_dir, os.path.basename(img_src))
                    if os.path.exists(potential_path):
                        file_path = potential_path
                        break
        
        # Try to delete the file if we found a valid path
        if file_path and os.path.exists(file_path) and os.path.isfile(file_path):
            try:
                os.remove(file_path)
                count += 1
                print(f"Successfully deleted: {file_path}")  # Debug log
            except (OSError, PermissionError) as e:
                # Log the error but continue with other files
                print(f"Error deleting embedded image {img_src} at {file_path}: {e}")
        else:
            # Try a simpler approach using just the filename as a last resort
            filename = os.path.basename(img_src)
            last_resort_paths = [
                os.path.join(settings.MEDIA_ROOT, filename),
                os.path.join(settings.MEDIA_ROOT, 'uploads', filename),
                os.path.join(settings.MEDIA_ROOT, 'images', filename),
                os.path.join(settings.MEDIA_ROOT, 'embedded', filename)
            ]
            
            for path in last_resort_paths:
                if os.path.exists(path) and os.path.isfile(path):
                    try:
                        os.remove(path)
                        count += 1
                        print(f"Successfully deleted using filename match: {path}")
                        break
                    except (OSError, PermissionError) as e:
                        print(f"Error deleting embedded image by filename {filename} at {path}: {e}")
            else:
                print(f"Could not locate file for deletion: {img_src}")  # Debug log
    
    return count

@user_passes_test(admin_required, login_url='admin_login')
def confirm_delete_exploit(request, exploit_identifier):
    exploit = get_object_or_404(Exploit, id=exploit_identifier)

    return render(request, 'confirm_delete.html', {'exploit': exploit})

""" @user_passes_test(admin_required, login_url='admin_login')
def update_exploit(request, exploit_identifier):
    exploit_id = str(exploit_identifier)
    exploit = get_object_or_404(Exploit, id=exploit_identifier)

    if request.method == "POST":
        form = ExploitForm(request.POST, request.FILES, instance=exploit)
        if form.is_valid():
            form.save()
            for index, description in enumerate(request.POST.getlist("section_content[]")):
                desc_instance, created = ExploitDescription.objects.get_or_create(exploit=exploit, id=index+1)
                desc_instance.content = description
                desc_instance.image = request.FILES.getlist("section_image[]")[index] if "section_image[]" in request.FILES else desc_instance.image
                desc_instance.video = request.FILES.getlist("section_video[]")[index] if "section_video[]" in request.FILES else desc_instance.video
                desc_instance.file = request.FILES.getlist("section_file[]")[index] if "section_file[]" in request.FILES else desc_instance.file
                desc_instance.save()
            return redirect('home')

    else:
        form = ExploitForm(instance=exploit)
    
    return render(request, 'update_exploit.html', {'form': form, 'exploit': exploit}) """

logger = logging.getLogger(__name__)
    
def custom_login(request):
    form = LoginForm()
    if request.method == "POST":
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            return redirect('home')  
        else:
            return HttpResponse("Invalid credentials", status=401)
    else:
        form = AuthenticationForm()
    return render(request, 'admin_login.html', {'form': form})
    
def custom_logout(request):
    logout(request)
    return render(request, 'admin_logout.html')

def protected_view(request):
    if not request.user.is_authenticated:
        return redirect("session_expired")
    return render(request, "home.html")

def session_expired(request):
    return render(request, "session_expired.html")

def check_session(request):
    return JsonResponse({"is_authenticated": request.user.is_authenticated})

def view_file(request, file_path):
    try:
        if '..' in file_path:
            return HttpResponse("Invalid file path", status=400)
        
        # Construct the full path to the file
        full_path = os.path.join(settings.MEDIA_ROOT, file_path)
        
        if not os.path.exists(full_path):
            return HttpResponse(f"File not found: {full_path}", status=404)
        
        # Determine the content type
        content_type, _ = mimetypes.guess_type(full_path)
        if not content_type:
            content_type = 'application/octet-stream'
        
        # For text files, HTML, and other viewable formats
        viewable_types = ['dll', 'json', 'javascript', 'toml', 'md', 'pdf', 'docx', 'video', 'audio', 'cab', 'tex', 'svg', 'woff', 'woff2', 'eot', 'ttf', 'css', 'html', 'python', 'image', 'zip', 'tar', 'gzip', 'xml', 'pptx', 'text', 'csv', 'cpp', 'tsv', 'c', 'tfevents']
        is_viewable = False
        for vtype in viewable_types:
            if content_type.startswith(vtype):
                is_viewable = True
                break
        
        if is_viewable:
            # Read file content and return as HttpResponse
            with open(full_path, 'r') as f:
                content = f.read()
                response = HttpResponse(content, content_type=content_type)
                response['Content-Disposition'] = f'inline; filename="{os.path.basename(file_path)}"'
                return response
        else:
            # For other files, still allow download
            response = FileResponse(open(full_path, 'rb'), content_type=content_type)
            response['Content-Disposition'] = f'inline; filename="{os.path.basename(file_path)}"'
            return response
            
    except Exception as e:
        print(f"Error in view_file: {str(e)}")
        return HttpResponse(f"Error viewing file: {str(e)}", status=500)
    
@user_passes_test(admin_required, login_url='admin_login')
def import_exploits(request):
    """
    Imports exploits from an uploaded zip archive. This replaces all existing data.
    """
    # Handle GET request
    if request.method == "GET":
        return render(request, 'admin/import_exploits.html')  # Replace with your actual template
   
    # Debug and log incoming request data
    print("Content-Type:", request.content_type)
    print("POST keys:", request.POST.keys())
    print("FILES keys:", request.FILES.keys())
   
    # Check if request is multipart
    if not request.content_type or 'multipart/form-data' not in request.content_type:
        print("ERROR: Request is not multipart/form-data")
        return JsonResponse({"error": "Request must be multipart/form-data"}, status=400)
   
    # Try to get the file with different possible field names
    import_file = None
    possible_field_names = ['import_file', 'file', 'zipfile', 'importFile']
   
    for field_name in possible_field_names:
        if field_name in request.FILES:
            import_file = request.FILES[field_name]
            print(f"Found file in field: {field_name}")
            break
   
    if not import_file:
        print("ERROR: No file found in any of the expected fields")
        return JsonResponse({
            "error": "No file uploaded",
            "available_fields": list(request.FILES.keys()),
            "expected_fields": possible_field_names
        }, status=400)
   
    # Print details about the file
    print(f"File received: {import_file.name}, size: {import_file.size} bytes")
   
    # Check if file is empty
    if import_file.size == 0:
        return JsonResponse({"error": "Uploaded file is empty"}, status=400)
   
    # Validate file extension - allow both .zip and .json for testing
    if not (import_file.name.lower().endswith('.zip') or import_file.name.lower().endswith('.json')):
        return JsonResponse({"error": f"Unsupported file type: {import_file.name}. Please upload a ZIP file."}, status=400)
   
    # Create import directory with timestamp
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    import_dir = os.path.join(settings.MEDIA_ROOT, 'imports', f"import_{timestamp}")
    os.makedirs(import_dir, exist_ok=True)
   
    try:
        # Handle different file types
        if import_file.name.lower().endswith('.json'):
            # Direct JSON import (for testing/debug purposes)
            json_path = os.path.join(import_dir, 'metadata.json')
            with open(json_path, 'wb') as f:
                for chunk in import_file.chunks():
                    f.write(chunk)
                   
            # Read the JSON file
            with open(json_path, 'r', encoding='utf-8') as f:
                try:
                    exploit_data = json.load(f)
                except json.JSONDecodeError as e:
                    return JsonResponse({"error": f"Invalid JSON file: {str(e)}"}, status=400)
               
        else:
            # ZIP file handling
            zip_path = os.path.join(import_dir, 'import.zip')
            with open(zip_path, 'wb') as f:
                for chunk in import_file.chunks():
                    f.write(chunk)
           
            try:
                # Verify and extract the zip file
                with zipfile.ZipFile(zip_path, 'r') as zipf:
                    # Check if metadata.json exists in the zip
                    if "metadata.json" not in zipf.namelist():
                        return JsonResponse({"error": "metadata.json not found in ZIP. Available files: " +
                                           ", ".join(zipf.namelist())}, status=400)
                    zipf.extractall(import_dir)
               
                # Load the metadata.json file
                metadata_path = os.path.join(import_dir, "metadata.json")
                with open(metadata_path, 'r', encoding='utf-8') as f:
                    exploit_data = json.load(f)
                   
            except zipfile.BadZipFile:
                return JsonResponse({"error": "The uploaded file is not a valid ZIP archive"}, status=400)
       
        # Validate the loaded data
        if not isinstance(exploit_data, list):
            return JsonResponse({"error": "Invalid data format: expected a list of exploit objects"}, status=400)
           
        # Process the exploit data
        from django.db import transaction
       
        with transaction.atomic():
            # Clear existing data
            ExploitFile.objects.all().delete()
            Exploit.objects.all().delete()
           
            # Create exploit files directory
            exploit_files_dir = os.path.join(settings.MEDIA_ROOT, 'exploit_files')
            os.makedirs(exploit_files_dir, exist_ok=True)
           
            import_count = 0
           
            for data in exploit_data:
                # Create exploit object
                exploit = Exploit(
                    title=data.get("title", "Untitled Exploit"),
                    CVE_ID=data.get("CVE_ID", ""),
                    CVSS=data.get("CVSS", ""),
                    category=data.get("category", "Uncategorized"),
                    description=data.get("description", ""),
                )
               
                # Handle date if present
                if "date_added" in data and data["date_added"]:
                    try:
                        # Try to parse the date string
                        date_str = data["date_added"]
                        # Handle ISO format dates
                        exploit.date_added = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                    except ValueError:
                        # If parsing fails, use current date
                        pass
               
                exploit.save()
                import_count += 1
               
                # Handle files if ZIP was uploaded
                if import_file.name.lower().endswith('.zip'):
                    exploit_id = str(data.get("id", "unknown"))
                    exploit_file_dir = os.path.join(import_dir, "files", exploit_id)
                   
                    if os.path.exists(exploit_file_dir):
                        for file_name in os.listdir(exploit_file_dir):
                            src_path = os.path.join(exploit_file_dir, file_name)
                            unique_name = f"{exploit.id}_{file_name}"
                            dst_path = os.path.join(exploit_files_dir, unique_name)
                           
                            # Copy the file
                            shutil.copy2(src_path, dst_path)
                           
                            # Create file record
                            ExploitFile.objects.create(
                                exploit=exploit,
                                file=os.path.join('exploit_files', unique_name),
                                name=file_name
                            )
       
        # Clean up
        shutil.rmtree(import_dir)
       
        # Return success message
        return JsonResponse({
            "success": True,
            "message": f"Successfully imported {import_count} exploits"
        })
       
    except Exception as e:
        import traceback
        error_details = traceback.format_exc()
        print("IMPORT ERROR:", error_details)
        return JsonResponse({
            "error": f"Import failed: {str(e)}",
            "details": error_details
        }, status=500)


@user_passes_test(admin_required, login_url='admin_login')
def export_exploits(request):
    """
    Exports all exploit data (including related files) into a zip archive.
    """
    import json
   
    # Define custom encoder for MongoDB types
    class MongoJSONEncoder(json.JSONEncoder):
        def default(self, obj):
            from bson.decimal128 import Decimal128
            if isinstance(obj, Decimal128):
                return float(str(obj))
            # Add other MongoDB types as needed
            return super().default(obj)
   
    export_dir = os.path.join(settings.MEDIA_ROOT, 'exports')
    os.makedirs(export_dir, exist_ok=True)


    zip_path = os.path.join(export_dir, 'exploits_export.zip')


    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        exploits = Exploit.objects.all()
        export_data = []


        for exploit in exploits:
            exploit_dict = {
                "id": exploit.id,
                "title": exploit.title,
                "CVE_ID": exploit.CVE_ID,
                "CVSS": exploit.CVSS,  # Use the CVSS directly - encoder will handle it
                "category": exploit.category,
                "description": exploit.description,
                "date_added": str(exploit.date_added),
            }
            export_data.append(exploit_dict)


            # Add related files
            related_files = ExploitFile.objects.filter(exploit=exploit)
            for file_obj in related_files:
                if file_obj.file:
                    file_path = file_obj.file.path
                    if os.path.exists(file_path):
                        zipf.write(file_path, os.path.join(f"files/{exploit.id}", os.path.basename(file_path)))


        # Save metadata JSON inside zip - USE THE CUSTOM ENCODER HERE
        json_metadata = json.dumps(export_data, indent=4, cls=MongoJSONEncoder)
        zipf.writestr("metadata.json", json_metadata)


    with open(zip_path, 'rb') as zip_file:
        response = HttpResponse(zip_file.read(), content_type='application/zip')
        response['Content-Disposition'] = f'attachment; filename="exploits_export.zip"'
        return response
